#+TITLE: ORG-MODE
#+STARTUP: overview

#+begin_src emacs-lisp
(require 'org)
(require 'org-tempo)
#+end_src

** BASE SETTINGS

#+begin_src emacs-lisp
 (setq org-directory "~/org")
 (setq org-agenda-files '("~/org/todo.org"))
 (setq org-refile-targets '(("~/org/todo.org" :maxlevel . 3)))
 (setq org-archive-location "~/org/archive.org::* From %s")
 (setq org-todo-keywords
       '((sequence "TODO(t)" "NOTE(n)" "DONE(d)" "CANCEL(c)")))
 (setq org-log-done 'time)
 (setq org-src-fontify-natively t)
 (setq org-src-tab-acts-natively t)
 (setq org-edit-src-content-indentation 1)
 (setq org-export-with-smart-quotes t)
 (setq org-export-with-toc t)
 (setq org-hide-emphasis-markers t)
 ;; Activate speed keys
 (setq org-use-speed-commands t)
#+end_src

** LOAD BABEL LANGUAGES

#+begin_src emacs-lisp
 (org-babel-do-load-languages
  'org-babel-load-languages
  '((C . t)
    (emacs-lisp . t)
    (shell . t)
    (rust . t)
    (js . t)
    (latex . t)
    (python . t)
    (scheme .t)))
#+end_src

** STRUCTURE TEMPLATES

#+begin_src emacs-lisp
 (add-to-list 'org-structure-template-alist '("s" . "src"))
 (add-to-list 'org-structure-template-alist '("kr" . "src C"))
 (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
 (add-to-list 'org-structure-template-alist '("rs" . "src rust"))
 (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
 (add-to-list 'org-structure-template-alist '("tex" . "src latex"))
#+end_src

** CAPTURE TASK

#+begin_src emacs-lisp
 (defvar my/capture-last-title nil
   "Title from the last my/capture-file call, reused in template body.")

 (defun my/org-title-to-path (dir title)
   "Return a new .org file path in DIR for TITLE.
Capitalizes first letter, replaces spaces with underscores.
Sets `my/capture-last-title'.  Errors if file already exists."
   (let* ((capitalized (concat (upcase (substring title 0 1))
                               (substring title 1)))
          (filename (concat (replace-regexp-in-string " " "_" capitalized) ".org"))
          (path (expand-file-name filename dir)))
     (when (file-exists-p path)
       (user-error "File already exists: %s" path))
     (setq my/capture-last-title capitalized)
     path))

 (defun my/capture-file (dir prompt)
   "Prompt for a title and return a new .org file path in DIR."
   (let ((trimmed (string-trim (read-string prompt))))
     (when (string-empty-p trimmed)
       (user-error "Title cannot be empty"))
     (my/org-title-to-path dir trimmed)))

 (defun my/capture-title ()
   "Return the title saved by my/capture-file."
   my/capture-last-title)

 (defun my/sync-reference-categories ()
   "Rebuild ~/org/.categories from FILETAGS across all org files."
   (when (and buffer-file-name
              (string-suffix-p ".org" buffer-file-name)
              (string-prefix-p (expand-file-name org-directory)
                               (expand-file-name buffer-file-name)))
     (let (tags)
       (dolist (f (directory-files-recursively org-directory "\\.org$"))
         (with-temp-buffer
           (insert-file-contents f nil 0 512)
           (when (re-search-forward "^#\\+TYPE:[ \t]*category" nil t)
             (cl-pushnew (file-name-base f) tags :test #'string=))))
       (with-temp-file (expand-file-name ".categories" org-directory)
         (insert (mapconcat #'identity (sort tags #'string<) "\n") "\n")))))

 (add-hook 'after-save-hook #'my/sync-reference-categories)

 (defun my/select-categories (prompt)
   "Select one or more categories from ~/org/.categories with PROMPT.
Returns a list of selected category strings."
   (let* ((file (expand-file-name ".categories" org-directory))
          (cats (when (file-exists-p file)
                  (with-temp-buffer
                    (insert-file-contents file)
                    (split-string (buffer-string) "\n" t)))))
     (unless cats
       (user-error "No categories found. Create one with C-c c K first"))
     (let ((chosen '())
           (done nil))
       (while (not done)
         (let* ((remaining (cl-remove-if (lambda (c) (member c chosen)) cats))
                (candidates (if chosen (append '("[done]") remaining) remaining))
                (pick (completing-read
                       (if chosen
                           (format "%s [%s]: " prompt
                                   (mapconcat #'identity (reverse chosen) ", "))
                         (format "%s: " prompt))
                       candidates nil t)))
           (if (or (string-empty-p pick) (string= pick "[done]"))
               (setq done t)
             (push pick chosen))))
       (unless chosen
         (user-error "No selection made"))
       (nreverse chosen))))

 (defun my/reference-categories ()
   "Select categories for a Reference capture template."
   (mapconcat #'identity (my/select-categories "Category") ":"))

 (setq org-capture-templates
       '(("t" "TODO" entry (file+headline "~/org/todo.org" "CURRENT")
	  "* TODO %?\n %i\n %a")

	 ("n" "Note" plain (file (lambda ()
	   (my/capture-file "~/org" "Note title: ")))
	  "#+TITLE: %(my/capture-title)\n#+DATE: %U\n#+FILETAGS:\n\n[[file:Daily/%(format-time-string \"%Y-%m-%d\").org][%(format-time-string \"%Y-%m-%d\")]]\n\n%?")

	 ("r" "Reference" plain (file (lambda ()
	   (my/capture-file "~/org/References" "Reference title: ")))
	  "#+TITLE: %(my/capture-title)\n#+DATE: %U\n#+FILETAGS: :%(my/reference-categories):\n\n%?")

	 ("K" "Category" plain (file (lambda ()
	   (my/capture-file "~/org" "Category name: ")))
	  "#+TITLE: %(my/capture-title)\n#+DATE: %U\n#+TYPE: category\n\n%?")

	 ("c" "Clipping" plain (file (lambda ()
	   (my/capture-file "~/org/Clippings" "Clipping title: ")))
	  "#+TITLE: %(my/capture-title)\n#+DATE: %U\n#+FILETAGS: :Manuscripts:\n\nSource: %^{URL}\n\n%?")

	 ("w" "Weekly review" plain (file (lambda ()
	   (expand-file-name
	    (concat "Week" (format-time-string "%U") "_-_" (format-time-string "%b_%Y") ".org")
	    "~/org")))
	  "#+TITLE: Week%(format-time-string \"%%U\") - %(format-time-string \"%%b %%Y\")\n#+DATE: %U\n#+FILETAGS: :weekly:\n\n* What happened\n\n%?\n\n* What I learned\n\n* Next week\n")))
#+end_src

**** BACKLINK HELPERS

#+begin_src emacs-lisp
 (defun my/org-ensure-backlink (target-file source-file source-title)
   "Ensure TARGET-FILE contains a backlink to SOURCE-FILE with SOURCE-TITLE.
 Opens TARGET-FILE, inserts the link under a `* Backlinks (N)' heading
 (created if absent), and updates the count."
   (when (file-exists-p target-file)
     (let* ((rel-path (file-relative-name source-file (file-name-directory target-file)))
            (link (format "[[file:%s][%s]]" rel-path source-title)))
       (with-current-buffer (find-file-noselect target-file)
         ;; Check for duplicate anywhere in the buffer
         (goto-char (point-min))
         (unless (search-forward link nil t)
           ;; Find or create the Backlinks heading
           (goto-char (point-min))
           (if (re-search-forward "^\\* Backlinks ([0-9]+)" nil t)
               ;; Heading exists — go to end of its subtree
               (let ((start (point)))
                 (org-end-of-subtree t)
                 (unless (bolp) (insert "\n"))
                 (insert (format "- %s\n" link))
                 ;; Update count
                 (goto-char start)
                 (beginning-of-line)
                 (let ((count 0))
                   (save-excursion
                     (org-end-of-subtree t)
                     (let ((end (point)))
                       (goto-char start)
                       (while (re-search-forward "^- \\[\\[file:" end t)
                         (cl-incf count))))
                   (when (re-search-forward "(\\([0-9]+\\))" (line-end-position) t)
                     (replace-match (number-to-string count) t t nil 1))))
             ;; No heading yet — create at end of file
             (goto-char (point-max))
             (unless (bolp) (insert "\n"))
             (insert (format "* Backlinks (1)\n\n- %s\n" link))))
         (save-buffer)))))
#+end_src

**** DAILY BACKLINK ON CAPTURE

#+begin_src emacs-lisp
 (defun my/org-add-daily-backlink (note-file title)
   "Ensure today's daily file exists and has a backlink to NOTE-FILE with TITLE."
   (let* ((daily-dir (expand-file-name "Daily" org-directory))
          (daily-path (expand-file-name (format-time-string "%Y-%m-%d.org") daily-dir)))
     (unless (file-exists-p daily-dir) (make-directory daily-dir t))
     (with-current-buffer (find-file-noselect daily-path)
       (when (= (buffer-size) 0)
         (insert (format "#+TITLE: %s\n#+DATE: %s\n\n"
                         (format-time-string "%Y-%m-%d")
                         (format-time-string "[%Y-%m-%d %a]")))
         (save-buffer)))
     (my/org-ensure-backlink daily-path note-file title)))

 (defun my/org-capture-add-daily-backlink ()
   "After capturing a note, add a backlink in today's daily file."
   (when (and (equal (plist-get org-capture-plist :key) "n")
              my/capture-last-title)
     (my/org-add-daily-backlink
      (expand-file-name
       (concat (my/org-title-to-filename my/capture-last-title) ".org")
       org-directory)
      my/capture-last-title)))

 (add-hook 'org-capture-after-finalize-hook #'my/org-capture-add-daily-backlink)
#+end_src

**** INTERNAL LINK BACKLINKS ON SAVE

#+begin_src emacs-lisp
 (defun my/org-sync-backlinks ()
   "After saving an org file, ensure backlinks exist in all internally linked files.
 Category files (#+TYPE: category) are skipped so that backlinks accumulated
 in them do not trigger reverse links."
   (when (and (my/org-sync-scope-p)
              (not my/org-sync-in-progress)
              (not (save-excursion
                     (goto-char (point-min))
                     (re-search-forward "^#\\+TYPE:[ \t]*category" nil t))))
     (let ((my/org-sync-in-progress t)
           (source-file buffer-file-name)
           (source-title (or (my/org-get-title)
                             (file-name-base buffer-file-name)))
           (source-dir (file-name-directory buffer-file-name)))
       (save-excursion
         (goto-char (point-min))
         (while (re-search-forward "\\[\\[file:\\([^]]+\\.org\\)\\]" nil t)
           (let* ((rel (match-string-no-properties 1))
                  (target (expand-file-name rel source-dir)))
             (when (and (file-exists-p target)
                        (not (equal (file-truename target)
                                    (file-truename source-file))))
               (my/org-ensure-backlink target source-file source-title))))))))

 (add-hook 'after-save-hook #'my/org-sync-backlinks)
#+end_src

** DEFT

#+begin_src emacs-lisp
 (use-package deft
   :config
   (setq deft-directory org-directory
         deft-extensions '("org")
         deft-recursive t
         deft-use-filename-as-title nil
         deft-org-mode-title-prefix t)
   :bind (:map deft-mode-map
               ("C-c C-n" . my/deft-new-note)))

 (defun my/deft-new-note ()
   "Create a new note from the current Deft filter string."
   (interactive)
   (let* ((raw (string-trim (deft-whole-filter-regexp))))
     (when (string-empty-p raw)
       (user-error "No search term to create a note from"))
     (let* ((path (my/org-title-to-path org-directory raw))
            (title my/capture-last-title)
            (daily (format-time-string "%Y-%m-%d"))
            (daily-link (format "[[file:Daily/%s.org][%s]]" daily daily)))
       (let ((win (selected-window)))
         (kill-buffer (current-buffer))
         (select-window win)
         (switch-to-buffer (find-file-noselect path)))
       (insert (format "#+TITLE: %s\n#+DATE: %s\n#+FILETAGS:\n\n%s\n\n" title
                       (format-time-string "[%Y-%m-%d %a %H:%M]")
                       daily-link))
       (save-buffer)
       (my/org-add-daily-backlink path title))))
#+end_src

**** TASK ARCHIVE

#+begin_src emacs-lisp
(defun my/mark-done-and-archive ()
  "Mark the state of an org-mode item as DONE and archive it."
  (interactive)
  (org-todo 'done)
  (org-archive-subtree))

(define-key org-mode-map (kbd "C-c C-x C-s") 'my/mark-done-and-archive)
#+end_src

** KEYBINDINGS

#+begin_src emacs-lisp
 (defun my/org-daily-file ()
   "Open or create today's daily anchor file."
   (interactive)
   (let* ((dir (expand-file-name "Daily" org-directory))
	  (file (expand-file-name (format-time-string "%Y-%m-%d.org") dir)))
     (unless (file-exists-p dir) (make-directory dir t))
     (find-file file)
     (when (= (buffer-size) 0)
       (insert (format "#+TITLE: %s\n#+DATE: %s\n"
		       (format-time-string "%Y-%m-%d")
		       (format-time-string "[%Y-%m-%d %a]"))))))

 (defun my/org-insert-link ()
   "Insert an org file link with description derived from filename.
Prompts for an .org file under `org-directory' and inserts a relative
link with the title inferred from the filename (underscores → spaces)."
   (interactive)
   (let* ((files (directory-files-recursively org-directory "\\.org$"))
          (names (mapcar (lambda (f) (file-relative-name f org-directory)) files))
          (pick (completing-read "Link to: " names nil t))
          (abs (expand-file-name pick org-directory))
          (base-dir (if buffer-file-name
                        (file-name-directory buffer-file-name)
                      (expand-file-name org-directory)))
          (rel (file-relative-name abs base-dir))
          (title (my/org-filename-to-title (file-name-base abs))))
     (insert (format "[[file:%s][%s]]" rel title))))

 (define-key global-map "\C-ca" 'org-agenda)
 (define-key global-map "\C-cc" 'org-capture)
 (define-key global-map "\C-cn" 'my/org-daily-file)
 (define-key org-mode-map (kbd "C-c l") #'my/org-insert-link)
#+end_src

*** SET FILETAGS

#+begin_src emacs-lisp
 (defun my/set-filetags ()
   "Set #+FILETAGS: in current buffer, completing from .categories.
 Also creates backlinks in each selected category file."
   (interactive)
   (let* ((tags (my/select-categories "Tags"))
          (value (concat ":" (mapconcat #'identity tags ":") ":")))
     (save-excursion
       (goto-char (point-min))
       (if (re-search-forward "^#\\+FILETAGS:.*$" nil t)
           (replace-match (concat "#+FILETAGS: " value))
         (goto-char (point-min))
         (let ((insert-pos (point)))
           (while (re-search-forward "^#\\+[A-Z_]+:" nil t)
             (setq insert-pos (line-end-position)))
           (goto-char insert-pos)
           (insert "\n#+FILETAGS: " value))))
     ;; Create backlinks in category files
     (when buffer-file-name
       (let ((source-file buffer-file-name)
             (source-title (or (my/org-get-title)
                               (file-name-base buffer-file-name))))
         (dolist (tag tags)
           (let ((cat-file (car (directory-files-recursively
                                 org-directory
                                 (concat "\\`" (regexp-quote tag) "\\.org\\'")))))
             (when cat-file
               (my/org-ensure-backlink cat-file source-file source-title))))))))

 (define-key org-mode-map (kbd "C-c t") #'my/set-filetags)
#+end_src

** EXPORTING
*** LATEX

#+begin_src emacs-lisp
 (require 'ox-latex)
#+end_src

*** DISABLE ASKING BEFORE EVALUATION

#+begin_src emacs-lisp
 (setq org-confirm-babel-evaluate nil)
#+end_src

*** HTMLIZE FOR ORG EXPORTS

#+begin_src emacs-lisp
 (use-package htmlize)
#+end_src

**** Footer configuration

#+begin_src emacs-lisp
(setq org-html-postamble nil)
#+end_src

*** ORG EXPORT FOR GITHUB MARKDOWN

#+begin_src emacs-lisp
 (use-package ox-gfm)
#+end_src

** PLUGINS

 #+begin_src emacs-lisp
  (use-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

  (use-package org-cliplink
    :config
    (define-key org-mode-map (kbd "C-c M-l") #'org-cliplink))
 #+end_src

** HOOKS
*** IN-BUFFER SETTING

#+begin_src emacs-lisp
 (defun my/org-mode-auto-titles ()
   (when (and (stringp buffer-file-name)
	      (string-match "\\.org$" buffer-file-name))
     (let ((title (file-name-base buffer-file-name)))
       (if (string-match "\\`[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}-.*\\'" title)
	   (progn
	     (insert (concat "#+TITLE: " (replace-regexp-in-string "\\`[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}-" "" title) "\n"))
	     (insert "#+LAYOUT: post\n")
	     (insert "#+OPTIONS: f:t\n"))))))
#+end_src

#+begin_src emacs-lisp
 (add-hook 'find-file-hook 'my/org-mode-auto-titles)
#+end_src

*** AUTO FILL MODE

#+begin_src emacs-lisp
 (add-hook 'org-mode-hook 'auto-fill-mode)
#+end_src

*** INLINE IMAGES

#+begin_src emacs-lisp
 (setq org-startup-with-inline-images t)
#+end_src

*** LAST MODIFIED TIMESTAMP

#+begin_src emacs-lisp
 (defun my/org-update-last-modified ()
   "Update #+LAST_MODIFIED: on save for org files under ~/org/."
   (when (and (derived-mode-p 'org-mode)
              (buffer-file-name)
              (string-prefix-p (expand-file-name org-directory)
                               (expand-file-name (buffer-file-name))))
     (save-excursion
       (goto-char (point-min))
       (when (re-search-forward "^#\\+LAST_MODIFIED:.*$" (min (point-max) 1000) t)
         (replace-match (format "#+LAST_MODIFIED: %s"
                                (format-time-string "[%Y-%m-%d %a %H:%M]")))))))

 (add-hook 'before-save-hook #'my/org-update-last-modified)
#+end_src

*** TITLE / FILENAME SYNC

#+begin_src emacs-lisp
 (defvar my/org-sync-in-progress nil
   "Non-nil while title/filename sync is running, to prevent recursion.")

 (defvar-local my/org-prev-title nil
   "The #+TITLE value when the buffer was opened or last synced.")

 (defun my/org-get-title ()
   "Return the #+TITLE value from the current buffer, or nil."
   (save-excursion
     (goto-char (point-min))
     (when (re-search-forward "^#\\+TITLE:[ \t]+\\(.+\\)" nil t)
       (let ((val (string-trim (match-string-no-properties 1))))
         (unless (string-empty-p val) val)))))

 (defun my/org-title-to-filename (title)
   "Convert TITLE to filename base (spaces → underscores)."
   (replace-regexp-in-string " " "_" title))

 (defun my/org-filename-to-title (base)
   "Convert filename BASE to title (underscores → spaces)."
   (replace-regexp-in-string "_" " " base))

 (defun my/org-sync-scope-p (&optional file)
   "Return non-nil if FILE should participate in title/filename sync.
 Excludes daily files, weekly reviews, and files outside the vault."
   (let ((f (or file buffer-file-name)))
     (and f
          (string-suffix-p ".org" f)
          (string-prefix-p (expand-file-name org-directory)
                           (expand-file-name f))
          (let ((base (file-name-base f)))
            (not (or (string-match-p "\\`[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\'" base)
                     (string-match-p "\\`Week[0-9]" base)))))))

 (defun my/org-update-backlinks (old-base new-base old-title new-title)
   "Rewrite every org link referencing OLD-BASE.org in the vault.
 Updates the file path and, when the description matches OLD-TITLE,
 the description text.  Returns the number of files modified."
   (let ((files (directory-files-recursively org-directory "\\.org$"))
         (count 0)
         (link-re (concat "\\[\\[file:\\([^]]*?\\)"
                          (regexp-quote (concat old-base ".org"))
                          "\\]"))
         (desc-old (concat "][" old-title "]]"))
         (desc-new (concat "][" new-title "]]")))
     (dolist (f files)
       (let ((buf (find-buffer-visiting f)))
         (if buf
             ;; File is open in a buffer — edit the buffer
             (with-current-buffer buf
               (save-excursion
                 (let ((mod nil))
                   (goto-char (point-min))
                   (while (re-search-forward link-re nil t)
                     (replace-match (concat "[[file:\\1" new-base ".org]") t)
                     (setq mod t))
                   (unless (string= old-title new-title)
                     (goto-char (point-min))
                     (while (search-forward desc-old nil t)
                       (replace-match desc-new t t)
                       (setq mod t)))
                   (when mod (save-buffer) (cl-incf count)))))
           ;; File not open — use temp buffer for speed
           (with-temp-buffer
             (insert-file-contents f)
             (let ((mod nil))
               (goto-char (point-min))
               (while (re-search-forward link-re nil t)
                 (replace-match (concat "[[file:\\1" new-base ".org]") t)
                 (setq mod t))
               (unless (string= old-title new-title)
                 (goto-char (point-min))
                 (while (search-forward desc-old nil t)
                   (replace-match desc-new t t)
                   (setq mod t)))
               (when mod
                 (write-region (point-min) (point-max) f)
                 (cl-incf count)))))))
     count))

 ;; Record title on open for change detection
 (defun my/org-record-title ()
   "Snapshot #+TITLE so we can detect changes on the next save."
   (when (my/org-sync-scope-p)
     (setq my/org-prev-title (my/org-get-title))))

 (add-hook 'find-file-hook #'my/org-record-title)

 ;; Title changed → rename file + update backlinks
 (defun my/org-sync-title-to-filename ()
   "After save: if #+TITLE changed, rename the file and rewrite backlinks."
   (when (and (my/org-sync-scope-p)
              (not my/org-sync-in-progress))
     (let* ((title (my/org-get-title))
            (fname (file-name-base buffer-file-name))
            (expected (when title (my/org-title-to-filename title))))
       (when (and title expected
                  (not (string= expected fname))
                  my/org-prev-title
                  (not (string= title my/org-prev-title)))
         (let* ((dir (file-name-directory buffer-file-name))
                (new-path (expand-file-name (concat expected ".org") dir))
                (my/org-sync-in-progress t))
           (when (file-exists-p new-path)
             (user-error "Cannot rename: %s already exists" new-path))
           (rename-file buffer-file-name new-path)
           (set-visited-file-name new-path t t)
           (set-buffer-modified-p nil)
           (let ((n (my/org-update-backlinks fname expected
                                             my/org-prev-title title)))
             (message "Renamed → %s.org  (%d backlink file%s updated)"
                      expected n (if (= n 1) "" "s")))
           (setq my/org-prev-title title))))))

 (add-hook 'after-save-hook #'my/org-sync-title-to-filename)

 ;; File renamed externally → update title + backlinks
 (defun my/org-sync-filename-to-title ()
   "On open: if filename doesn't match #+TITLE, sync title and backlinks."
   (when (and (my/org-sync-scope-p)
              (not my/org-sync-in-progress))
     (let* ((title (my/org-get-title))
            (fname (file-name-base buffer-file-name))
            (expected (when title (my/org-title-to-filename title))))
       (when (and title expected
                  (not (string= expected fname)))
         (let ((new-title (my/org-filename-to-title fname))
               (old-base expected)
               (my/org-sync-in-progress t))
           (save-excursion
             (goto-char (point-min))
             (when (re-search-forward "^#\\+TITLE:[ \t]+.*$" nil t)
               (replace-match (concat "#+TITLE: " new-title))))
           (save-buffer)
           (let ((n (my/org-update-backlinks old-base fname title new-title)))
             (message "Title synced → %s  (%d backlink file%s updated)"
                      new-title n (if (= n 1) "" "s")))
           (setq my/org-prev-title new-title))))))

 (add-hook 'find-file-hook #'my/org-sync-filename-to-title)
#+end_src
