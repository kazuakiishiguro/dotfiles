* Code generation
** company
#+begin_src emacs-lisp
(use-package company
  :defines (company-dabbrev-ignore-case company-dabbrev-downcase)
  :init
  (setq company-auto-complete nil)
  (setq company-idle-delay 0)
  (setq company-require-match nil)
  :config
  (global-company-mode 1)
  (define-key company-active-map (kbd "C-n") 'company-select-next)
  (define-key company-active-map (kbd "C-p") 'company-select-previous)
  (define-key company-search-map (kbd "C-n") 'company-select-next)
  (define-key company-search-map (kbd "C-p") 'company-select-previous))
#+end_src

* Lint
** flycheck
#+begin_src emacs-lisp
(use-package flycheck
  :config (global-flycheck-mode))
#+end_src

* Language Server Protocol
** lsp-mode
#+begin_src emacs-lisp
(use-package lsp-mode
 :custom((lsp-prefer-flymake nil)
 (lsp-auto-configure t)
 (lsp-rust-server 'rust-analyzer)
 (lsp-keep-workspace-alive nil))
 :hook (lsp-mode . lsp-enable-which-key-integration))
#+end_src

** rust-analyzer for rust-server
#+begin_src emacs-lisp
(setq lsp-rust-server 'rust-analyzer)
#+end_src

** lsp-ui
#+begin_src emacs-lisp
(use-package lsp-ui
  :hook (lsp-mode . lsp-ui-mode)
  :custom ((lsp-ui-doc-include-signature t)
           (lsp-ui-doc-enable nil))
  :bind (:map lsp-ui-mode-map
              ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
              ([remap xref-find-references] . lsp-ui-peek-find-references)
              ("C-c l i" . lsp-ui-imenu)
              ("C-c l d" . lsp-ui-doc-show)))
#+end_src

** company-lsp
#+begin_src emacs-lisp
(use-package company-lsp
  :config (push 'company-lsp company-backends)
  :custom (company-lsp-async t))
#+end_src

** lsp-treemacs
#+begin_src emacs-lisp
(use-package lsp-treemacs
  :commands lsp-treemacs-errors-list)
#+end_src
* Utils
** Smart parens
#+begin_src emacs-lisp
(use-package smartparens
  :config
  (smartparens-global-mode 1))
#+end_src

** Smart new line
[[https://gist.github.com/brianloveswords/e23cedf3a80bab675fe5][https://gist.github.com/brianloveswords/e23cedf3a80bab675fe5]]
#+begin_src emacs-lisp
(defun my/smart-newline ()
  "Add two newlines and put the cursor at the right indentation
     between them if a newline is attempted when the cursor is between
     two curly braces, otherwise do a regular newline and indent"
  (interactive)
  (if (or
       (and (equal (char-before) 123) ; {
            (equal (char-after) 125)) ; }
       (and (equal (char-before) 40)  ; (
            (equal (char-after) 41))) ; )
       (progn (newline-and-indent)
            (split-line)
            (indent-for-tab-command))
            (newline-and-indent)))

(global-set-key (kbd "RET") 'my/smart-newline)
#+end_src

** Multiple cursors
#+begin_src emacs-lisp
(use-package multiple-cursors
  :bind
  ("C-c m e" . mc/edit-lines)
  ("C->" . mc/mark-next-like-this)
  ("C-<" . mc/mark-previous-like-this)
  ("C-c m a" . mc/mark-all-like-this))
#+end_src

