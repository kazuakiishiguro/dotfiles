#+TITLE: My Personal Emacs Configuration
#+AUTHOR: Kazuaki Ishiguro
#+EMAIL: gurokazu@gmail.com

* Initial configuration
** =use-package= to install and configure my packages
   Use =use-package-ensure= to configure my packages and always =:ensure t=.
#+BEGIN_SRC emacs-lisp
  (require 'use-package-ensure)
  (setq use-package-always-ensure t)
#+END_SRC
* UI preferences
** Basics
   I do not use the menu or scroll bar.
#+BEGIN_SRC emacs-lisp
  (tooltip-mode -1)
  (menu-bar-mode -1)
#+END_SRC
*** Font setting
    I prefer to use =Source Code Pro= font.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Source Code Pro-13"))
#+END_SRC
** Startup screen
   I prefer simple startup screen
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC
** Window management
*** Split
   I like to set a shortcut key to split window with =C-c w h= =C-c w v= keys.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c w h") 'split-window-horizontally)
  (global-set-key (kbd "C-c w v") 'split-window-vertically)
#+END_SRC
**** Threshhold
   I also would like to set =split-width-threshold= to =0= to split window horizontally when I am coding.
#+BEGIN_SRC emacs-lisp
  (setq split-height-threshold nil)
#+END_SRC
** Minor modes
*** =minions=
    Using =minions= to hide all the minor modes in the modeline instead of manually adding =:diminish= to every =use-package= declaration.
#+BEGIN_SRC emacs-lisp
  (use-package minions
    :config
    (minions-mode 1))
#+END_SRC
** Uncommited changes
*** Highlight uncommitted changes
    Use =git-gutter= to highlight concommitted changes.
#+BEGIN_SRC emacs-lisp
  (use-package git-gutter
    :defer t
    :init
    (add-hook 'org-mode-hook 'git-gutter-mode))
#+END_SRC
* Editor setting
** Configuration files
*** Edit
    I edit my dotfiles quite often. This binds =C-c f= . to quickly open my Emacs configuratiobn file.
#+BEGIN_SRC emacs-lisp
  (defun my/visit-emacs-config ()
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))

  (global-set-key (kbd "C-c f .") 'my/visit-emacs-config)
#+END_SRC
*** Reload
    Once you have finished editing, you might want to source the file and reload. So this is the custom fuctoin that I made with =C-c f r=.
#+BEGIN_SRC emacs-lisp
  (defun my/reload-emacs-config ()
    (interactive)
    (load-file "~/.emacs.d/init.el"))

  (global-set-key (kbd "C-c f r") 'my/reload-emacs-config)
#+END_SRC
** Completion
   I use =helm= for incremental completion and selection narrowing.
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :config
    (helm-mode 1))
#+END_SRC
** Keybindings in popup
   I use =which-key= to find out which keybindings are available.
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :init
    (setq which-key-separator " ")
    (setq which-key-prefix-prefix "+")
    :config
    (which-key-mode 1))
#+END_SRC
** Disable visual bell
   Because I do not need this function.
#+BEGIN_SRC emacs-lisp
  (setq rign-bell-function 'ignore)
#+END_SRC
** Always kill current buffer
   Assume that I always want to kill the current buffer when hitting =C-x k=.
#+BEGIN_SRC emacs-lisp
  (defun my/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'my/kill-current-buffer)
#+END_SRC
** Delete other windows setting
   Keymap for =delete-other-windows=.
#+BEGIN_SRC emacs-lisp
  (defun my/kill-another-buffer ()
    "Kill another buffer if it exists."
    (interactive)
    (delete-other-windows))

  (global-set-key (kbd "C-q") 'my/kill-another-buffer)
#+END_SRC
** Insert line before
   Insert a newline(s) above the line contain in the cursor.
   So tha you do not have to move your cursor.
#+BEGIN_SRC emacs-lisp
  (defun my/insert-line-before ()
    "Insert a newline(s) above the line containing the cursor."
    (interactive)
    (save-excursion
      (move-beginning-of-line 1)
      (newline)))

  (global-set-key (kbd "C-o") 'my/insert-line-before)
#+END_SRC
** Disable backup and autosave
   It prevents to create extra files while you are working on your program.
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+END_SRC
** Enable =electric-pair-mode=
   For inserting parenthesis/brackats.
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
#+END_SRC
** Share =$PATH=
#+BEGIN_SRC emacs-lisp
  (defun my/set-exec-path-from-shell-PATH ()
    "Set up Emacs' `exec-path` and PATH environment variable to match that used by the use's shell."
    (interactive)
    (let ((path-from-shell (replace-regexp-in-string "[ \t\n]*$" "" (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
      (setenv "PATH" path-from-shell)
      (setq exec-path (split-string path-from-shell path-separator))))

  (my/set-exec-path-from-shell-PATH)
#+END_SRC
* Programming environment
** Compnay
   Use =company-mode= for auto completion.
#+BEGIN_SRC emacs-lisp
  (use-package company
    :init
    (setq company-auto-complete nil)
    (setq company-idle-delay 0.1)
    (setq company-require-match 'never)
    :config
    (global-company-mode 1)
    (define-key company-active-map (kbd "C-n") 'company-select-next)
    (define-key company-active-map (kbd "C-p") 'company-select-previous)
    (define-key company-search-map (kbd "C-n") 'company-select-next)
    (define-key company-search-map (kbd "C-p") 'company-select-previous))
#+END_SRC
** Rust
   I <3 Rust.
   Currently I use:
   - =flychek-rust=
   - =rustic=
   - =rust-analyzer=
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-rust)

  (use-package rustic
    :hook
    (rust-mode . lsp-deferred)
    (rust-mode . company-mode)
    (flycheck-mode . flycheck-rust-setup)
    :custom
    (rustic-format-on-save t)
    (rustic-indent-method-chain t)
    ;; The default is 'rls
    (rustic-lsp-server 'rust-analyzer)
    :bind
    ("C-c ." . lsp-execute-code-action)
    ("C-c r" . xref-find-references))
#+END_SRC
** Solidity
   Basic setup for =solidity= development.
#+BEGIN_SRC emacs-lisp
  (use-package solidity-mode
    :interpreter ("solc" . solidity-mode)
    :config
    (setq-default
     c-basic-offset 4
     tab-width 4
     indent-tabs-mode t))
#+END_SRC
** ShellScript
   Indent with 2 spaces.
#+BEGIN_SRC emacs-lisp
  (add-hook 'sh-mode-hook
    (lambda ()
      (setq sh-basic-offset 2
	sh-indentation 2)))
#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
  (use-package python
    :mode ("\\.py\\'" . python-mode)
    :interpreter ("python" . python-mode))
#+END_SRC
** Web-mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode (("\\.html?\\'" . web-mode)
	      ("\\.jsx?$\\'" . web-mode))
  :config
  (setq web-mode-content-types-alist '(("jsx" . "\\.js[x]?\\'")))
  (setq-default web-mode-markup-indent-offset 2)
  (setq web-mode-code-indent-offset 2))
#+END_SRC
** JavaScript
   Also need minimal =rjsx-mode= is needed for Javascirpt development.
#+BEGIN_SRC emacs-lisp
  (use-package rjsx-mode
    :mode
    (("\\.js$" . rjsx-mode)
     ("\\.jsx$" . rjsxx-mode))
    :init
    (setq
     js-indent-level 2
     js2-basic-offset 2
     js2-strict-missing-semi-warning nil))
#+END_SRC
** TypeScript
   Why not use strictly typed language, right? So I use =tide= for typescript-mode.
#+BEGIN_SRC emacs-lisp
  (use-package typescript-mode
    :config
    (use-package tide
      :after (typescript-mode company flycheck)
      :hook ((typescript-mode . tide-setup)
	     (typescript-mode . tide-hl-identifier-mode)
	     (before-save . tide-format-before-save)))
    :mode "\\.ts\\'")
#+END_SRC
* Org-mode
** Display
*** Syntax highlighting
    Use syntax highlighting in source blocks while editing.
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC
*** Window
    When editing a code snippet, use the current window rather than popping open a new one (which shows the same information).
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
** Editing
*** =TAB= action
    Make =TAB= act as if it were issued in a buffer of the language’s major mode
#+BEGIN_SRC emacs-lisp
  (setq org-src-tab-acts-natively t)
#+END_SRC
*** Template
    Quickly insert a block of elisp.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
		 '("el" . "src emacs-lisp"))
#+END_SRC
** Task management
*** File directory
    Store my org files in =~/org=, and archive finished tasks in =~/org/archive.org=.
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/org")

  (defun org-file-path (filename)
     "Return the absolute address of an org file, given its relative name"
     (concat (file-name-as-directory org-directory) filename))

  (setq org-index-file (org-file-path "index.org"))
  (setq org-archive-location
	 (concat (org-file-path "archive.org") "::* From %s"))
#+END_SRC
*** Index file
    I store all my todos in =~/org/index.org=, so I’d like to derive my agenda from there.
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-index-file))
#+END_SRC
*** Capture
**** =TODO= keywords
     I like to set =TODO= keywords as follows:
#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
	'((sequence "TODO(t)" "NOTE(n)" "DONE(d)" "CANCEL(c)")))
#+END_SRC
**** Capturing tasks
     Define a few common tasks as capture templates.
+ Record ideas for future blog posts in =~/org/notes/blog-ideas.org=,
+ Maintain a todo list in =~/org/index.org=
#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
      '(("b" "Blog idea"
	 entry
	 (file "~/org/notes/blog-ideas.org")
	 "* %?\n")
	("n" "Note taking"
	 entry
	 (file "~/org/notes/note.org")
	 "* %?\n %U %f")
	("t" "Todo"
	 entry
	 (file+headline org-index-file "Inbox")
	 "* TODO %?\n")))
#+END_SRC
**** Task archive
     Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate place in the archive.
#+BEGIN_SRC emacs-lisp
  (defun my/mark-done-and-archive ()
    "Mark the state of an org-mode item as DONE and archive it."
    (interactive)
    (org-todo 'done)
    (org-archive-subtree))

  (define-key org-mode-map (kbd "C-c C-x C-s") 'my/mark-done-and-archive)
#+END_SRC
**** Time keeping
     Record the time that a todo was archived.
#+BEGIN_SRC emacs-lisp
  (setq org-log-done 'time)
#+END_SRC
*** Keybindings
**** Basics
     Bind a key for org-mode.
#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-ca" 'org-agenda)
  (define-key global-map "\C-cc" 'org-capture)
#+END_SRC
**** =index.org= access
     Hit =C-c i= to quickly open index file.
#+BEGIN_SRC emacs-lisp
  (defun my/org-open-index ()
    "Open the master TODO list."
      (interactive)
      (find-file org-index-file)
      (flycheck-mode -1)
      (end-of-buffer))

  (global-set-key (kbd "C-c i") 'my/org-open-index)
#+END_SRC
**** Capture template access
     Hit =M-n= to quickly open up a capture template for a new todo.
#+BEGIN_SRC emacs-lisp
  (defun my/org-capture-todo ()
    (interactive)
    (org-capture :keys "t"))

  (global-set-key (kbd "M-n") 'my/org-capture-todo)
#+END_SRC
** Exporting
**** =org-babel= settings
     Allow babel to evaluate languages.
     Currently those languages are able to eveluate:
     + emacs-lisp
     + shell
     + js
     + latex
     + rust
     + python
#+BEGIN_SRC emacs-lisp
  (org-babel-do-load-languages
    'org-babel-load-languages
    '((emacs-lisp . t)
      (shell . t)
      (js . t)
      (latex . t)
      (rust . t)
      (python . t)))
#+END_SRC
Don't ask before evaluating code blocks
#+BEGIN_SRC emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+END_SRC
**** Rust
     Import =ob-rust= package to allow babel to evaluate.
#+BEGIN_SRC emacs-lisp
  (use-package ob-rust)
#+END_SRC
**** htmlize for org exports
     I use =htmlize= for html exporting
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC
***** Footer configuration
      Don't include a footer with my contract and publishing information at the bottom of every exported HTML document.
#+BEGIN_SRC emacs-lisp
  (setq org-html-postamble nil)
#+END_SRC
